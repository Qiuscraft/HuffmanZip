**huffmanzip开发文档**

**项目名称：huffmanzip**

**作者：丘俊**

**学号：23307130289**

**目录：**

[TOC]

# 一、代码结构

- `main.cpp`：处理用户交互，接收用户输入的指令并调用相应函数。
- `HuffmanCode.h(cpp)`：哈夫曼编码类。
- `HuffmanNode.h(cpp)`：哈夫曼结点类。
- `HuffmanTree.h(cpp)`：哈夫曼树类。
- `HuffmanZip.h(cpp)`：哈夫曼压缩工具类。
- `Counter.h(cpp)`：字符计数工具类。
- `XOREncryption.h(cpp)`：异或加密算法类。
- `BitInBuffer.h(cpp)`：解压过程中需要使用的缓冲区类。
- `BitOutBuffer.h(cpp)`：压缩过程中需要使用的缓冲区类。

# 二、设计思路

## 1. 文件的压缩与解压

压缩过程：

1. 将文件按字节读取，每个字节可以等价于一个`char`，即字符。首先遍历文件的每个字符，从而计算每个字符出现的次数。由此构建哈夫曼树。
2. 将序列化后的哈夫曼树的字符串的长度及内容写入压缩包文件。
3. 将文件名字符串长度及内容写入压缩包文件。
4. 将`uint64_t(0)和uint32_t(0)`写入压缩包文件，这是在为文件位数、文件末尾对齐所需补零位数预留空间。
5. 再遍历一次文件的每个字符，将字符对应的哈夫曼编码写入压缩包文件，并记录写入总位数。
6. 读到文件末尾时，由于文件大小需要对齐至`1byte`，即写入总位数必须是8的倍数，根据写入总位数，为文件补`0`。
7. 在先前预留的空间写入文件总位数和文件末尾对齐所需补零位数。

**注：事实上，压缩过程一个一个读取字节会涉及大量IO操作，降低性能。因此我设计了一个`BitOutBuffer`类。这个类使用一个`__uint128_t`类型数组提供了一个连续容器，并通过位运算实现数据的输入与输出。由于数组存储在内存空间中是连续的，并且数据的输入与输出通过位运算实现，性能要高于标准库的`std::bitset`与`std::vector<bool>`。经测试，性能最好的数组大小为4，具体原因就不得而知了。**

解压过程：

1. 读取一位`uint32_t`数据，由于文件写入是先写入序列化后哈夫曼树字符串的大小，所以会读取到它。再根据这个大小读取序列化后的哈夫曼树字符串，并将其反序列化。
2. 同理，读取文件名长度并根据长度读取文件名。
3. 读取文件位数、文件末尾对齐所需补零位数，从而计算实际的文件位数。根据实际文件位数一位一位地读取内容，在哈夫曼树上找到编码对应的字符，把字符写入输出文件中。

**注1：事实上，解压过程必须按字节从文件中读取内容，因此需要实现一个缓冲区`BitInBuffer`，这个缓冲区每次从文件中读取1字节的内容，输入到`std::bitset<8>`中，提供一个`readBit()`函数，从而实现按位读取内容。**

**注2：哈夫曼树的序列化与反序列化是这样实现的：在压缩过程中，我们必然需要一个函数，这个函数通过一个记录了各个字符出现数量的数组`uint64_t countArray[256]`构建哈夫曼树。我实现的序列化与反序列化的过程就是序列化与反序列化这个数组的过程。只要数组序列化前后不变，构建出来的树也是不变的，并且这样不涉及嵌套结构，更容易也更省空间。序列化数组思路如下：遍历每一个出现次数不为0的字符`c`，他的出现次数为`countArray[c]`，将`c`写入序列化后的字符串，再将`countArray[c]`以二进制形式写入序列化后的字符串。由于这是一个`uint64_t`类型的数据，所以记录一个字符的出现次数总共需要9个字节。反序列化时类似地读取即可。**

**注3：前面所有的`uint64_t`的使用都是为了防止`int`溢出。**

**注4：由于保存了文件长度，所以上述程序自然能够解压缩空文件。**

## 2. 文件夹的压缩与解压

压缩过程：

1. 由于我们前面对每个文件的压缩操作会记录文件的文件名，事实上，这也同时记录了文件的相对路径，也就是说，文件是在哪个目录下的这个信息是被保存了的。在解压文件过程时，编写程序自动创建对应的目录，这是可以做到的。因此我们只需要记录那些空文件夹的信息，因为这些文件夹没有文件，所以我们需要特别处理一下。先深度遍历所有文件夹，找到空文件夹，将空文件夹的路径写入一个字符串，用`\n`分隔。然后将字符串的长度和内容写入压缩包的开头。
2. 深度遍历文件夹，遍历所有文件，计算字符出现的数量。构造哈夫曼树，将序列化后的哈夫曼树大小及内容写入压缩包。
3. 深度遍历文件夹，遍历所有文件，按照之前单文件压缩步骤3、4、5、6、7，将文件压缩进压缩包。

解压过程：

1. 读取空文件夹大小，按大小读取空文件夹字符串，将字符串以`\n`分割成多个字符串，调用库函数创建这些空文件夹。
2. 像之前一样读取树。
3. 像之前一样解压每一个文件。由于我们写入了文件位数，所以可以轻松的找到文件末尾的位置，这个位置也是下一个文件开头的位置。一直解压直至压缩包的末尾。

## 3. 设置压缩密码

使用异或加密算法对序列化后的哈夫曼树字符串进行加密。算法特点是不需要往压缩包中存储另外的信息，保证了压缩效率。同时不会往压缩包中存储任何明文信息，一定程度上确保了安全性。

压缩时，通过取余操作，使得序列化后的哈夫曼树字符串的每一个字符对应密码字符串中的每一个字符，将这两个字符做异或操作，得到新的字符，加密完成。

解压缩时，由于：
$$
a \oplus b \oplus b = a
$$
其中`a`，`b`都表示`0`或`1`。

根据公式可知，只需在对加密后的字符串做一次异或加密操作，就可以得到解密后的字符串。从而还原哈夫曼树，正确解压。当然，前提是两次输入的密码相同。如果密码不相同，就会解压出错误的乱码文件。

## 4. 代码风格

代码在编写时会对必要的位置进行注释（例如大段逻辑与magic numbers）。命名规范大部分时候采用驼峰命名法，有时候编写的对STL库内容执行操作的函数则与STL库一样使用小写字母+下划线的命名。

## 5. 用户交互

程序用法：

```
huffmanzip -c(ompress) <input> [<output>] [-p <password>] [-y]
huffmanzip -d(ecompress) <input> [<output>] [-p <password>] [-y]
```

其中：

- `()`表示其中的内容可以省略。

- `-c`表示压缩，`-d`表示解压。
- `<input>`是输入的文件或文件夹的路径。
- `[]`表示可选。
- `[<output>]`是输出的文件或文件夹的路径，这个选项是可选的。如果不输入，压缩时，`<output>`的值默认为`<input>.huffmanzip`；解压时，`<output>`的值默认为`<input>`。
- `[-p <password>]`表示设置压缩密码。这个选项也是可选的。
- `[-y]`表示遇到文件冲突时强制覆盖，不做任何提示。这个选项是可选的。

## 6. 鲁棒性

用户在使用工具解压的时候可能会输入错误参数，这个问题，只需分析参数错误的点并给予用户提示即可，如果用户输入不明所以，也会弹出具体的`usage`提示，具体实现在`main.cpp`中。

当是解压一个不是由我们的压缩工具创建的文件时，程序会告诉用户解压的不是我们创建的文件。难点在于如何分辨这个文件是不是我们创建的。我在压缩过程中文件最开头写入了一个`char(127)`，这是删除符，所有文本文件以及绝大多数文件都不会以这个符号开头。解压时先判断输入文件的第一个字符是否为`char(127)`，如果不是，弹出提示并退出程序。

## 7. 文件覆盖问题

在压缩和解压缩创建新文件之前，都会检查文件是否存在。如果文件存在并且调用程序时没有使用`-y`参数，就会询问用户是否需要覆盖。当且仅当用户回复`Y`或`y`时会覆盖，如果用户回复了别的内容或者没有回复，那么如果是压缩过程就会停止压缩，解压过程就会跳过解压该文件。

# 三、开发环境

系统：Windows

IDE：VS Code

编译：在文件根目录运行`build.bat`，前提是安装了`g++`编译器且配置好环境变量且编译器支持`c++20`标准。

**注：使用c++20标准的原因是项目中使用了三方运算符进行重载`>`、`>=`、`==`、`<`、`<=`操作符。这个特性使得代码风格保持清爽，这个特性在c++20支持。**

# 四、性能测试结果

| 测试用例                   | 初始大小（Bytes） | 压缩后大小（Bytes） | 压缩率 |
| -------------------------- | ----------------- | ------------------- | ------ |
| testcase01EmptyFile        | 0                 | 54                  | ∞      |
| testcase02NormalSingleFile | 23,903,670        | 20,940,032          | 0.876  |
| testcase03XLargeSingleFile | 1,105,931,880     | 738,375,974         | 0.668  |
| testcase4EmptyFolder       | 0                 | 36                  | ∞      |
| testcase5NomalFolder       | 5,945,430         | 4,658,924           | 0.784  |
| testcase06SubFolders       | 448,515,860       | 448,307,285         | 1.000  |
| testcase07XlargeSubFolders | 1,099,970,162     | 716,867,836         | 0.651  |
| testcase08Speed            | 643,412,034       | 411,715,793         | 0.640  |
| testcase09Ratio            | 441,771,600       | 277,051,973         | 0.627  |

# 五、遇到的问题和解决方案

## 1. 调试问题

程序免不了出bug，需要查看十六进制文件和`gdb`跟踪调试，其中，查看十六进制文件我使用的是VS Code 插件Hex Editor。

## 2. 小端序大端序问题

在压缩和解压过程中，我将`uint64_t`以二进制形式写入压缩包，并在解压过程通过文件流的`read`按照`sizeof(uint64_t)`读取出来，这是完全没问题的。

但在序列化哈夫曼树过程中，我将`uint64_t`以二进制形式写入字符串。库函数却没有提供一个类似的`read`函数，使得我可以按照相同的方式读取数据。在我编写开发文档的这一刻，我认为可以使用`stringstream`帮助我做这件事情。但在编写代码的时候，脑子没有这么灵光。我起初将`uint64_t`写入字符串后再一个一个字节读取的过程中，发现读取的内容顺序相反。例如，我原先写入`0a 0b 0c 0d 0e 0f 77 88`，读取时会变成`88 77 0f 0e 0d 0c 0b 0a`。相当于同一个数从原来的小端序形式变成了大端序形式，精神状态不佳的我手撸了一些位运算解决这件事情：

```cpp
std::string HuffmanNode::serialize(const HuffmanNode *node) {
	std::string result;
	if (node != nullptr) {
		std::queue<const HuffmanNode *> nodeQueue;
		nodeQueue.push(node);

		while (!nodeQueue.empty()) {
			const HuffmanNode *currentNode = nodeQueue.front();
			nodeQueue.pop();

			if (currentNode == nullptr)
				continue;

			nodeQueue.push(currentNode->leftChild);
			nodeQueue.push(currentNode->rightChild);

			if (currentNode->isLeaf()) {
				result.push_back(currentNode->data);
				// 转大端序
				uint64_t big_endian_value = 
					((currentNode->count & 0x00000000000000FF) << 56) | 
					((currentNode->count & 0x000000000000FF00) << 40) |
					((currentNode->count & 0x0000000000FF0000) << 24) |
					((currentNode->count & 0x00000000FF000000) << 8)  |
					((currentNode->count & 0x000000FF00000000) >> 8)  |
					((currentNode->count & 0x0000FF0000000000) >> 24) |
					((currentNode->count & 0x00FF000000000000) >> 40) |
					((currentNode->count & 0xFF00000000000000) >> 56);
				result.append(reinterpret_cast<const char*>(&big_endian_value), sizeof(big_endian_value));
			}
		}
	}
	return result;
}

void HuffmanNode::serializedStringToCountArray(const std::string &serialized_string, uint64_t *countArray) {
    memset(countArray, 0, sizeof(uint64_t) * 256);

    if (serialized_string.size() % 9 != 0)
        throw std::domain_error("Incorrect serialized_string.size() when deserializing a HuffmanNode.");
    
    for (size_t i = 0; i < serialized_string.size() / 9; i++) {
        uint64_t amount = 0;
        for (size_t j = 0; j < 8; ++j) {
            amount |= 
            (static_cast<uint64_t>(static_cast<unsigned char>(serialized_string[i * 9 + 1 + j]))
                 << (8 * (7 - j)));
        }
        countArray[static_cast<unsigned char>(serialized_string[i * 9])] += amount;
    }
}
```

总之也算是解决了问题。

> When I wrote this code, only God and I understood what I did. 

> Now only God knows.

## 3. 性能问题

曾经我压缩`testcase08Speed`需要`700`多秒，于是我对`BitOutBuffer`进行了一些优化。

> 这个类使用一个`__uint128_t`类型数组提供了一个连续容器，并通过位运算实现数据的输入与输出。由于数组存储在内存空间中是连续的，并且数据的输入与输出通过位运算实现，性能要高于标准库的`std::bitset`与`std::vector<bool>`。经测试，性能最好的数组大小为4，具体原因就不得而知了。

经过这个优化后，压缩`testcase08Speed`只需要`300`秒左右。性能提升非常之大！

还对各种实现过程中进行了一些零散优化，效果有但不佳。

最牛逼的优化是编译时打开`-Ofast`，由于此程序不涉及任何浮点数运算，同时作为小程序，我对自己的逻辑实现有足够的信心，因此可以打开`-Ofast`。打开后，压缩`testcase08Speed`只需20秒左右。

# 六、后记

基本上程序的所有特殊实现与细节都在前面说明过了！

这是我上大学以来做的第一个PJ，自认为程序已经十分健壮，或许代码风格部分还可以有一些重构，但实在没有精力，我马上要去做ICS的PJ了(=◉ᆽ◉=)转专业人真的忙，其他同学上个学期已经修过这门课了。

对于代码风格部分，还希望助教指点：我自认为在大多数类的实现上保持着较好的代码风格，做好了合适的函数抽象。但感觉注释上写得比较少，有很多内容我认为是不需要注释一看便懂的。但同时在`HuffmanZip`和`HuffmanNode`这两个类上，感觉程序实在是过于冗长，抽象出了十几个函数方法，函数之间又有许多的跳转，一个`.cpp`文件有几百行，修改也不便。请问：1）我的注释写的合适吗？2）我后面提到的这两个类或者其他的类写的合适吗？有没有改进建议？

如果可以得到指点，不胜感激！我的邮箱是`23307130289@m.fudan.edu.cn`，姓名为丘俊，谢谢！

